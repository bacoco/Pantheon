# Docker Generator Library

## Overview
The Docker Generator Library provides intelligent Dockerfile and Docker Compose generation based on project type, framework, and requirements.

## Core Components

### 1. Docker Template Engine
```typescript
interface DockerTemplate {
  name: string;
  framework: string;
  baseImage: string;
  stages: DockerStage[];
  metadata: {
    description: string;
    tags: string[];
    securityFeatures: string[];
    optimizations: string[];
  };
}

interface DockerStage {
  name: string;
  from: string;
  workdir: string;
  commands: DockerCommand[];
  expose?: number[];
  entrypoint?: string[];
  cmd?: string[];
}

interface DockerCommand {
  instruction: string;
  value: string | string[];
  comment?: string;
}
```

### 2. Framework Detection & Mapping
```typescript
const FRAMEWORK_DOCKER_MAP = {
  'next.js': {
    baseImage: 'node:18-alpine',
    template: 'nextjs-optimized',
    buildCommand: 'npm run build',
    startCommand: 'npm start',
    port: 3000
  },
  'express': {
    baseImage: 'node:18-alpine',
    template: 'node-api',
    buildCommand: 'npm ci --only=production',
    startCommand: 'node server.js',
    port: 3000
  },
  'fastapi': {
    baseImage: 'python:3.11-slim',
    template: 'python-api',
    buildCommand: 'pip install -r requirements.txt',
    startCommand: 'uvicorn main:app',
    port: 8000
  },
  'django': {
    baseImage: 'python:3.11-slim',
    template: 'django-app',
    buildCommand: 'pip install -r requirements.txt',
    startCommand: 'gunicorn config.wsgi:application',
    port: 8000
  },
  'react': {
    baseImage: 'node:18-alpine',
    template: 'react-spa',
    buildCommand: 'npm run build',
    serveWith: 'nginx:alpine',
    port: 80
  },
  'vue': {
    baseImage: 'node:18-alpine',
    template: 'vue-spa',
    buildCommand: 'npm run build',
    serveWith: 'nginx:alpine',
    port: 80
  }
};
```

### 3. Multi-Stage Build Optimization
```typescript
function generateMultiStageDockerfile(config: DockerConfig): string {
  const stages: string[] = [];
  
  // Dependencies stage
  stages.push(`
# Dependencies stage
FROM ${config.baseImage} AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
`);

  // Build stage
  stages.push(`
# Build stage
FROM ${config.baseImage} AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN ${config.buildCommand}
`);

  // Production stage
  stages.push(`
# Production stage
FROM ${config.baseImage} AS runner
WORKDIR /app

# Security: Run as non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

# Copy built application
COPY --from=builder --chown=nodejs:nodejs /app/.next ./.next
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package.json ./package.json

USER nodejs
EXPOSE ${config.port}

CMD ["${config.startCommand}"]
`);

  return stages.join('\n');
}
```

### 4. Security Features
```typescript
const SECURITY_FEATURES = {
  nonRootUser: {
    commands: [
      'RUN addgroup -g 1001 -S appuser',
      'RUN adduser -S appuser -u 1001',
      'USER appuser'
    ]
  },
  minimalBase: {
    prefer: ['alpine', 'slim', 'distroless']
  },
  scanningIntegration: {
    comment: '# Run security scan: docker scan <image-name>'
  },
  secrets: {
    commands: [
      '# Use BuildKit secrets for sensitive data',
      '# RUN --mount=type=secret,id=api_key ...'
    ]
  }
};
```

### 5. Environment Configuration
```typescript
interface EnvConfig {
  development: Record<string, string>;
  production: Record<string, string>;
  required: string[];
  optional: string[];
}

function generateEnvTemplate(config: EnvConfig): string {
  return `
# Required environment variables
${config.required.map(key => `# ${key}=`).join('\n')}

# Optional environment variables
${config.optional.map(key => `# ${key}=`).join('\n')}

# Development defaults
${Object.entries(config.development)
  .map(([key, value]) => `${key}=${value}`)
  .join('\n')}
`;
}
```

### 6. Docker Compose Generation
```typescript
interface ComposeService {
  image?: string;
  build?: {
    context: string;
    dockerfile?: string;
    args?: Record<string, string>;
  };
  ports?: string[];
  environment?: Record<string, string>;
  volumes?: string[];
  depends_on?: string[];
  healthcheck?: {
    test: string[];
    interval: string;
    timeout: string;
    retries: number;
  };
}

function generateDockerCompose(services: Record<string, ComposeService>): string {
  const compose = {
    version: '3.8',
    services,
    volumes: {},
    networks: {
      app: {
        driver: 'bridge'
      }
    }
  };
  
  return `# Generated by BACO Docker Generator
${JSON.stringify(compose, null, 2)
  .replace(/"/g, '')
  .replace(/,\n/g, '\n')}`;
}
```

## Usage Examples

### 1. Generate Dockerfile for Next.js App
```typescript
const dockerfile = generateDockerfile({
  framework: 'next.js',
  projectPath: './my-nextjs-app',
  features: ['multi-stage', 'security', 'cache-optimization']
});
```

### 2. Generate Full Stack Docker Compose
```typescript
const compose = generateFullStackCompose({
  frontend: {
    framework: 'react',
    port: 3000
  },
  backend: {
    framework: 'express',
    port: 5000
  },
  database: {
    type: 'postgres',
    version: '14'
  },
  cache: {
    type: 'redis',
    version: '7-alpine'
  }
});
```

### 3. Framework-Specific Optimizations
```typescript
const optimizedDockerfile = generateOptimizedDockerfile({
  framework: 'next.js',
  optimizations: [
    'standalone-output',
    'sharp-image-optimization',
    'layer-caching',
    'pruned-dependencies'
  ]
});
```

## Health Check Patterns

### API Health Checks
```dockerfile
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node healthcheck.js || exit 1
```

### Database Health Checks
```yaml
healthcheck:
  test: ["CMD", "pg_isready", "-U", "postgres"]
  interval: 10s
  timeout: 5s
  retries: 5
```

## Volume Mapping Strategies

### Development Volumes
```yaml
volumes:
  - ./src:/app/src          # Hot reload source
  - /app/node_modules       # Preserve container modules
  - ./public:/app/public    # Static assets
```

### Production Volumes
```yaml
volumes:
  - app-data:/app/data      # Persistent data
  - app-logs:/app/logs      # Log files
  - app-uploads:/app/uploads # User uploads
```

## Base Image Selection Logic

```typescript
function selectBaseImage(project: ProjectInfo): string {
  const { language, framework, requirements } = project;
  
  // Size-optimized images
  if (requirements.includes('minimal')) {
    return getMinimalImage(language);
  }
  
  // Security-focused images
  if (requirements.includes('security')) {
    return getHardenedImage(language);
  }
  
  // Performance-optimized images
  if (requirements.includes('performance')) {
    return getPerformanceImage(language);
  }
  
  // Default framework-specific images
  return FRAMEWORK_DOCKER_MAP[framework]?.baseImage || getDefaultImage(language);
}
```

## Integration with BACO

### Commands
- `/docker generate` - Generate Dockerfile for current project
- `/docker compose` - Generate docker-compose.yml
- `/docker optimize` - Optimize existing Dockerfile
- `/docker security` - Add security features to Dockerfile

### Workflow Integration
```typescript
// Automatically generate Docker files after project creation
if (config.docker.autoGenerate) {
  await generateDockerFiles(project);
}

// Include Docker in CI/CD setup
if (config.cicd.includeDocker) {
  await generateDockerCI(project);
}
```

## Error Handling

```typescript
class DockerGenerationError extends Error {
  constructor(message: string, public framework: string, public reason: string) {
    super(message);
    this.name = 'DockerGenerationError';
  }
}

function handleDockerError(error: DockerGenerationError): void {
  console.error(`Docker generation failed for ${error.framework}: ${error.reason}`);
  // Fallback to generic Dockerfile
  return generateGenericDockerfile();
}
```

## Security Scanning Integration

```yaml
# GitHub Actions integration
- name: Build and scan Docker image
  run: |
    docker build -t myapp:latest .
    docker scan myapp:latest --severity high
```

## Performance Metrics

- Multi-stage builds reduce image size by 60-80%
- Layer caching speeds up builds by 40-70%
- Alpine-based images are 5-10x smaller than default
- Optimized images start 2-3x faster

## Future Enhancements

1. **AI-Powered Optimization**: Analyze code to suggest optimal Docker configurations
2. **Kubernetes Integration**: Generate K8s manifests alongside Docker files
3. **Cloud-Specific Optimizations**: AWS ECS, Google Cloud Run, Azure Container Instances
4. **Buildpack Support**: Integration with Cloud Native Buildpacks
5. **Container Registry Integration**: Auto-push to DockerHub, ECR, GCR