# Product Requirements Prompt: Aurus - SBF 250 Portfolio Analyzer

## Goals

Build a web application that fetches comprehensive financial data for all SBF 250 (CAC All-Tradable) stocks using yfinance, provides powerful screening capabilities, and exports results to CSV for investment analysis. This is a personal tool for long-term investors who rebalance annually.

### Primary Goals:
1. Retrieve ALL available financial metrics for SBF 250 stocks via yfinance
2. Enable complex multi-criteria stock screening with AND/OR logic
3. Export filtered or complete datasets to CSV for Excel analysis
4. Provide on-demand data refresh capabilities

### Success Criteria:
- Successfully fetch data for all 250 stocks with proper error handling
- Filter stocks using any combination of 50+ financial metrics
- Export clean CSV files compatible with European Excel formats
- Complete weekend project with working MVP

## Context

You're building a financial analysis tool for a long-term investor who rebalances their portfolio annually. The SBF 250 index represents the largest tradable companies on the Paris stock exchange. The tool will help identify promising investment opportunities based on fundamental analysis.

### Technical Stack:
- **Frontend**: React (clean, data-focused UI)
- **Backend**: FastAPI (Python web framework)
- **Database**: SQLite (local storage)
- **Data Source**: yfinance Python library
- **Deployment**: Local only

### User Profile:
- Personal use only (no authentication needed)
- Long-term investment horizon (annual rebalancing)
- Needs comprehensive fundamental data, not day-trading indicators
- Comfortable with Excel for detailed analysis

## Tasks

### Phase 1: Foundation & Data Layer (4 hours)

#### 1.1 Project Setup
```bash
# Create project structure
aurus/
├── backend/
│   ├── app/
│   │   ├── __init__.py
│   │   ├── main.py           # FastAPI app
│   │   ├── models.py         # SQLAlchemy models
│   │   ├── schemas.py        # Pydantic schemas
│   │   ├── database.py       # Database connection
│   │   ├── services/
│   │   │   ├── __init__.py
│   │   │   ├── yfinance_service.py
│   │   │   ├── screening_service.py
│   │   │   └── export_service.py
│   │   └── routers/
│   │       ├── __init__.py
│   │       ├── stocks.py
│   │       ├── screening.py
│   │       └── export.py
│   ├── requirements.txt
│   └── sbf250_tickers.py     # List of SBF 250 tickers
├── frontend/
│   ├── src/
│   │   ├── components/
│   │   ├── services/
│   │   └── App.js
│   └── package.json
└── aurus.db                  # SQLite database
```

#### 1.2 Database Schema (SQLAlchemy Models)
```python
# backend/app/models.py
from sqlalchemy import Column, String, Float, DateTime, Integer, Text
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class Stock(Base):
    __tablename__ = "stocks"
    
    # Identifiers
    ticker = Column(String, primary_key=True)
    name = Column(String)
    sector = Column(String)
    industry = Column(String)
    
    # Price Data
    current_price = Column(Float)
    open_price = Column(Float)
    high_price = Column(Float)
    low_price = Column(Float)
    close_price = Column(Float)
    volume = Column(Integer)
    fifty_two_week_high = Column(Float)
    fifty_two_week_low = Column(Float)
    
    # Valuation Metrics
    market_cap = Column(Float)
    enterprise_value = Column(Float)
    pe_ratio = Column(Float)
    forward_pe = Column(Float)
    peg_ratio = Column(Float)
    price_to_book = Column(Float)
    price_to_sales = Column(Float)
    ev_to_ebitda = Column(Float)
    ev_to_revenue = Column(Float)
    
    # Financial Metrics
    revenue = Column(Float)
    revenue_growth = Column(Float)
    gross_profit = Column(Float)
    ebitda = Column(Float)
    net_income = Column(Float)
    earnings_growth = Column(Float)
    
    # Per Share Data
    eps = Column(Float)
    book_value_per_share = Column(Float)
    revenue_per_share = Column(Float)
    
    # Profitability Ratios
    gross_margin = Column(Float)
    operating_margin = Column(Float)
    profit_margin = Column(Float)
    roe = Column(Float)
    roa = Column(Float)
    
    # Financial Health
    current_ratio = Column(Float)
    quick_ratio = Column(Float)
    debt_to_equity = Column(Float)
    
    # Dividends
    dividend_yield = Column(Float)
    dividend_rate = Column(Float)
    payout_ratio = Column(Float)
    ex_dividend_date = Column(DateTime)
    
    # Technical Indicators
    beta = Column(Float)
    fifty_day_ma = Column(Float)
    two_hundred_day_ma = Column(Float)
    
    # Analyst Data
    target_price = Column(Float)
    recommendation = Column(String)
    number_of_analysts = Column(Integer)
    
    # Metadata
    last_updated = Column(DateTime)
    update_status = Column(String)  # 'success', 'failed', 'pending'
    error_message = Column(Text)

class ScreeningCriteria(Base):
    __tablename__ = "screening_criteria"
    
    id = Column(Integer, primary_key=True)
    name = Column(String, unique=True)
    description = Column(Text)
    criteria_json = Column(Text)  # Store filter criteria as JSON
    created_at = Column(DateTime)
    is_preset = Column(Integer)  # Boolean for built-in presets
```

#### 1.3 SBF 250 Ticker List
```python
# backend/app/sbf250_tickers.py
SBF250_TICKERS = [
    "AC.PA",      # Accor
    "ACA.PA",     # Credit Agricole
    "AI.PA",      # Air Liquide
    "AIR.PA",     # Airbus
    "ALO.PA",     # Alstom
    "ATO.PA",     # Atos
    "BN.PA",      # Danone
    "BNP.PA",     # BNP Paribas
    "CA.PA",      # Carrefour
    "CAP.PA",     # Capgemini
    "CS.PA",      # AXA
    "DG.PA",      # Vinci
    "EL.PA",      # EssilorLuxottica
    "EN.PA",      # Bouygues
    "ENGI.PA",    # Engie
    "FP.PA",      # Total
    "GLE.PA",     # Societe Generale
    "HO.PA",      # Thales
    "KER.PA",     # Kering
    "LR.PA",      # Legrand
    "MC.PA",      # LVMH
    "ML.PA",      # Michelin
    "OR.PA",      # L'Oreal
    "ORA.PA",     # Orange
    "PUB.PA",     # Publicis
    "RNO.PA",     # Renault
    "SAF.PA",     # Safran
    "SAN.PA",     # Sanofi
    "SGO.PA",     # Saint-Gobain
    "SU.PA",      # Schneider Electric
    "TTE.PA",     # TotalEnergies
    "VIE.PA",     # Veolia
    "VIV.PA",     # Vivendi
    # ... add all 250 tickers with .PA suffix
    # This is a subset - complete list needed for production
]

# Pre-built screening templates
SCREENING_PRESETS = {
    "value_stocks": {
        "name": "Value Stocks",
        "description": "Low P/E, High Dividend Yield",
        "criteria": {
            "pe_ratio": {"operator": "<", "value": 15},
            "dividend_yield": {"operator": ">", "value": 3},
            "logic": "AND"
        }
    },
    "growth_stocks": {
        "name": "Growth Stocks", 
        "description": "High Revenue & Earnings Growth",
        "criteria": {
            "revenue_growth": {"operator": ">", "value": 15},
            "earnings_growth": {"operator": ">", "value": 15},
            "logic": "AND"
        }
    },
    "quality_dividend": {
        "name": "Dividend Champions",
        "description": "Stable dividends with low payout ratio",
        "criteria": {
            "dividend_yield": {"operator": ">", "value": 2},
            "payout_ratio": {"operator": "<", "value": 60},
            "roe": {"operator": ">", "value": 15},
            "logic": "AND"
        }
    },
    "financially_healthy": {
        "name": "Financial Health",
        "description": "Strong balance sheet companies",
        "criteria": {
            "current_ratio": {"operator": ">", "value": 1.5},
            "debt_to_equity": {"operator": "<", "value": 0.5},
            "roe": {"operator": ">", "value": 10},
            "logic": "AND"
        }
    }
}
```

#### 1.4 yfinance Data Service
```python
# backend/app/services/yfinance_service.py
import yfinance as yf
import time
from datetime import datetime
from typing import Dict, List, Optional
import logging

logger = logging.getLogger(__name__)

class YFinanceService:
    def __init__(self):
        self.rate_limit_delay = 0.5  # 500ms between requests
        
    def fetch_stock_data(self, ticker: str) -> Optional[Dict]:
        """Fetch comprehensive data for a single stock"""
        try:
            stock = yf.Ticker(ticker)
            info = stock.info
            
            # Extract all available metrics with safe gets
            data = {
                # Identifiers
                'ticker': ticker,
                'name': info.get('longName', info.get('shortName', ticker)),
                'sector': info.get('sector', ''),
                'industry': info.get('industry', ''),
                
                # Price Data
                'current_price': info.get('currentPrice', info.get('regularMarketPrice')),
                'open_price': info.get('open', info.get('regularMarketOpen')),
                'high_price': info.get('dayHigh', info.get('regularMarketDayHigh')),
                'low_price': info.get('dayLow', info.get('regularMarketDayLow')),
                'close_price': info.get('previousClose'),
                'volume': info.get('volume', info.get('regularMarketVolume')),
                'fifty_two_week_high': info.get('fiftyTwoWeekHigh'),
                'fifty_two_week_low': info.get('fiftyTwoWeekLow'),
                
                # Valuation Metrics
                'market_cap': info.get('marketCap'),
                'enterprise_value': info.get('enterpriseValue'),
                'pe_ratio': info.get('trailingPE'),
                'forward_pe': info.get('forwardPE'),
                'peg_ratio': info.get('pegRatio'),
                'price_to_book': info.get('priceToBook'),
                'price_to_sales': info.get('priceToSalesTrailing12Months'),
                'ev_to_ebitda': info.get('enterpriseToEbitda'),
                'ev_to_revenue': info.get('enterpriseToRevenue'),
                
                # Financial Metrics
                'revenue': info.get('totalRevenue'),
                'revenue_growth': info.get('revenueGrowth'),
                'gross_profit': info.get('grossProfits'),
                'ebitda': info.get('ebitda'),
                'net_income': info.get('netIncomeToCommon'),
                'earnings_growth': info.get('earningsGrowth'),
                
                # Per Share Data
                'eps': info.get('trailingEps'),
                'book_value_per_share': info.get('bookValue'),
                'revenue_per_share': info.get('revenuePerShare'),
                
                # Profitability Ratios
                'gross_margin': info.get('grossMargins'),
                'operating_margin': info.get('operatingMargins'),
                'profit_margin': info.get('profitMargins'),
                'roe': info.get('returnOnEquity'),
                'roa': info.get('returnOnAssets'),
                
                # Financial Health
                'current_ratio': info.get('currentRatio'),
                'quick_ratio': info.get('quickRatio'),
                'debt_to_equity': info.get('debtToEquity'),
                
                # Dividends
                'dividend_yield': info.get('dividendYield'),
                'dividend_rate': info.get('dividendRate'),
                'payout_ratio': info.get('payoutRatio'),
                'ex_dividend_date': info.get('exDividendDate'),
                
                # Technical Indicators
                'beta': info.get('beta'),
                'fifty_day_ma': info.get('fiftyDayAverage'),
                'two_hundred_day_ma': info.get('twoHundredDayAverage'),
                
                # Analyst Data
                'target_price': info.get('targetMeanPrice'),
                'recommendation': info.get('recommendationKey'),
                'number_of_analysts': info.get('numberOfAnalystOpinions'),
                
                # Metadata
                'last_updated': datetime.now(),
                'update_status': 'success',
                'error_message': None
            }
            
            # Clean None values and convert timestamps
            data = {k: v for k, v in data.items() if v is not None}
            
            return data
            
        except Exception as e:
            logger.error(f"Error fetching data for {ticker}: {str(e)}")
            return {
                'ticker': ticker,
                'last_updated': datetime.now(),
                'update_status': 'failed',
                'error_message': str(e)
            }
    
    def fetch_all_sbf250(self, tickers: List[str], progress_callback=None) -> List[Dict]:
        """Fetch data for all SBF 250 stocks with progress tracking"""
        results = []
        total = len(tickers)
        
        for i, ticker in enumerate(tickers):
            # Progress callback
            if progress_callback:
                progress_callback(i + 1, total, ticker)
            
            # Fetch data
            data = self.fetch_stock_data(ticker)
            if data:
                results.append(data)
            
            # Rate limiting
            time.sleep(self.rate_limit_delay)
            
        return results
```

### Phase 2: API & Business Logic (4 hours)

#### 2.1 Screening Service
```python
# backend/app/services/screening_service.py
import json
from typing import List, Dict, Any
from sqlalchemy.orm import Session
from sqlalchemy import and_, or_
from app.models import Stock

class ScreeningService:
    def __init__(self, db: Session):
        self.db = db
        
    def apply_filters(self, criteria: Dict[str, Any]) -> List[Stock]:
        """Apply screening criteria to stocks"""
        query = self.db.query(Stock)
        
        # Handle AND/OR logic
        logic = criteria.get('logic', 'AND')
        conditions = []
        
        for field, condition in criteria.items():
            if field in ['logic']:
                continue
                
            operator = condition.get('operator')
            value = condition.get('value')
            
            # Build SQLAlchemy condition
            column = getattr(Stock, field)
            
            if operator == '>':
                conditions.append(column > value)
            elif operator == '<':
                conditions.append(column < value)
            elif operator == '>=':
                conditions.append(column >= value)
            elif operator == '<=':
                conditions.append(column <= value)
            elif operator == '=':
                conditions.append(column == value)
            elif operator == 'between':
                min_val = value.get('min')
                max_val = value.get('max')
                conditions.append(and_(column >= min_val, column <= max_val))
        
        # Apply logic
        if logic == 'AND':
            query = query.filter(and_(*conditions))
        else:
            query = query.filter(or_(*conditions))
            
        return query.all()
    
    def get_available_metrics(self) -> List[str]:
        """Return list of filterable metrics"""
        # Get column names excluding metadata
        exclude = ['ticker', 'name', 'sector', 'industry', 'last_updated', 
                  'update_status', 'error_message', 'ex_dividend_date']
        
        columns = [col.name for col in Stock.__table__.columns 
                  if col.name not in exclude]
        
        return sorted(columns)
```

#### 2.2 Export Service
```python
# backend/app/services/export_service.py
import csv
import io
from datetime import datetime
from typing import List, Dict, Optional
import pandas as pd

class ExportService:
    @staticmethod
    def export_to_csv(stocks: List[Stock], 
                     columns: Optional[List[str]] = None,
                     filters_applied: Optional[Dict] = None) -> str:
        """Export stocks to CSV with European formatting"""
        
        # Convert to pandas DataFrame
        data = []
        for stock in stocks:
            row = {col.name: getattr(stock, col.name) 
                  for col in stock.__table__.columns}
            data.append(row)
        
        df = pd.DataFrame(data)
        
        # Select columns if specified
        if columns:
            df = df[columns]
        
        # Format numbers for European Excel
        # Use semicolon as delimiter, comma as decimal separator
        for col in df.select_dtypes(include=['float']).columns:
            df[col] = df[col].apply(lambda x: f"{x:,.2f}".replace(',', 'X')
                                              .replace('.', ',')
                                              .replace('X', '.') 
                                   if pd.notna(x) else '')
        
        # Create CSV with metadata
        output = io.StringIO()
        
        # Write metadata
        output.write(f"# Aurus SBF 250 Export\n")
        output.write(f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        output.write(f"# Total Stocks: {len(stocks)}\n")
        
        if filters_applied:
            output.write(f"# Filters Applied: {json.dumps(filters_applied)}\n")
        
        output.write("#\n")
        
        # Write data
        df.to_csv(output, sep=';', index=False)
        
        return output.getvalue()
    
    @staticmethod
    def generate_filename(filtered: bool = False) -> str:
        """Generate filename following convention"""
        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
        prefix = "aurus_sbf250_filtered" if filtered else "aurus_sbf250_export"
        return f"{prefix}_{timestamp}.csv"
```

#### 2.3 FastAPI Routes
```python
# backend/app/main.py
from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from fastapi.responses import FileResponse
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from typing import List, Optional
import asyncio

from app.database import get_db, engine
from app.models import Base, Stock
from app.schemas import StockResponse, ScreeningRequest, UpdateProgress
from app.services.yfinance_service import YFinanceService
from app.services.screening_service import ScreeningService
from app.services.export_service import ExportService

# Create tables
Base.metadata.create_all(bind=engine)

app = FastAPI(title="Aurus SBF 250 Analyzer")

# CORS for React frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global state for update progress
update_progress = {"current": 0, "total": 0, "status": "idle", "current_ticker": ""}

@app.get("/api/stocks", response_model=List[StockResponse])
def get_all_stocks(db: Session = Depends(get_db)):
    """Get all stocks from database"""
    stocks = db.query(Stock).all()
    return stocks

@app.post("/api/stocks/screen", response_model=List[StockResponse])
def screen_stocks(request: ScreeningRequest, db: Session = Depends(get_db)):
    """Apply screening criteria to stocks"""
    screening_service = ScreeningService(db)
    filtered_stocks = screening_service.apply_filters(request.criteria)
    return filtered_stocks

@app.get("/api/stocks/metrics")
def get_available_metrics(db: Session = Depends(get_db)):
    """Get list of available metrics for filtering"""
    screening_service = ScreeningService(db)
    return {"metrics": screening_service.get_available_metrics()}

@app.post("/api/stocks/update")
async def update_all_stocks(background_tasks: BackgroundTasks, db: Session = Depends(get_db)):
    """Trigger update of all stock data"""
    background_tasks.add_task(update_stocks_task, db)
    return {"message": "Update started", "status": "processing"}

@app.get("/api/stocks/update/progress")
def get_update_progress():
    """Get current update progress"""
    return update_progress

@app.post("/api/export/csv")
def export_to_csv(
    columns: Optional[List[str]] = None,
    filters: Optional[Dict] = None,
    db: Session = Depends(get_db)
):
    """Export stocks to CSV"""
    # Get stocks (filtered or all)
    if filters:
        screening_service = ScreeningService(db)
        stocks = screening_service.apply_filters(filters)
    else:
        stocks = db.query(Stock).all()
    
    # Generate CSV
    csv_content = ExportService.export_to_csv(stocks, columns, filters)
    filename = ExportService.generate_filename(filtered=bool(filters))
    
    # Return as file download
    return Response(
        content=csv_content,
        media_type="text/csv",
        headers={"Content-Disposition": f"attachment; filename={filename}"}
    )

def update_stocks_task(db: Session):
    """Background task to update all stocks"""
    global update_progress
    
    yfinance_service = YFinanceService()
    from app.sbf250_tickers import SBF250_TICKERS
    
    update_progress["total"] = len(SBF250_TICKERS)
    update_progress["status"] = "running"
    
    def progress_callback(current, total, ticker):
        update_progress["current"] = current
        update_progress["current_ticker"] = ticker
    
    # Fetch all data
    stock_data = yfinance_service.fetch_all_sbf250(
        SBF250_TICKERS, 
        progress_callback
    )
    
    # Update database
    for data in stock_data:
        ticker = data['ticker']
        stock = db.query(Stock).filter(Stock.ticker == ticker).first()
        
        if stock:
            # Update existing
            for key, value in data.items():
                setattr(stock, key, value)
        else:
            # Create new
            stock = Stock(**data)
            db.add(stock)
    
    db.commit()
    
    update_progress["status"] = "completed"
    update_progress["current_ticker"] = ""
```

### Phase 3: React Frontend (4 hours)

#### 3.1 React App Setup
```javascript
// frontend/src/App.js
import React, { useState, useEffect } from 'react';
import StockGrid from './components/StockGrid';
import FilterPanel from './components/FilterPanel';
import UpdatePanel from './components/UpdatePanel';
import ExportPanel from './components/ExportPanel';
import './App.css';

function App() {
  const [stocks, setStocks] = useState([]);
  const [filteredStocks, setFilteredStocks] = useState([]);
  const [loading, setLoading] = useState(true);
  const [metrics, setMetrics] = useState([]);
  const [activeFilters, setActiveFilters] = useState({});

  useEffect(() => {
    // Load initial data
    fetchStocks();
    fetchMetrics();
  }, []);

  const fetchStocks = async () => {
    try {
      const response = await fetch('http://localhost:8000/api/stocks');
      const data = await response.json();
      setStocks(data);
      setFilteredStocks(data);
      setLoading(false);
    } catch (error) {
      console.error('Error fetching stocks:', error);
      setLoading(false);
    }
  };

  const fetchMetrics = async () => {
    try {
      const response = await fetch('http://localhost:8000/api/stocks/metrics');
      const data = await response.json();
      setMetrics(data.metrics);
    } catch (error) {
      console.error('Error fetching metrics:', error);
    }
  };

  const handleFilter = async (criteria) => {
    setActiveFilters(criteria);
    
    if (Object.keys(criteria).length === 0) {
      setFilteredStocks(stocks);
      return;
    }

    try {
      const response = await fetch('http://localhost:8000/api/stocks/screen', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ criteria })
      });
      const data = await response.json();
      setFilteredStocks(data);
    } catch (error) {
      console.error('Error filtering stocks:', error);
    }
  };

  return (
    <div className="App">
      <header className="App-header">
        <h1>Aurus - SBF 250 Portfolio Analyzer</h1>
        <div className="stats">
          Showing {filteredStocks.length} of {stocks.length} stocks
        </div>
      </header>
      
      <div className="App-body">
        <aside className="sidebar">
          <UpdatePanel onUpdate={fetchStocks} />
          <FilterPanel 
            metrics={metrics}
            onFilter={handleFilter}
            activeFilters={activeFilters}
          />
          <ExportPanel 
            activeFilters={activeFilters}
            metrics={metrics}
          />
        </aside>
        
        <main className="main-content">
          {loading ? (
            <div className="loading">Loading stocks...</div>
          ) : (
            <StockGrid stocks={filteredStocks} />
          )}
        </main>
      </div>
    </div>
  );
}

export default App;
```

#### 3.2 Stock Data Grid Component
```javascript
// frontend/src/components/StockGrid.js
import React, { useState, useMemo } from 'react';
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-alpine.css';

const StockGrid = ({ stocks }) => {
  const [gridApi, setGridApi] = useState(null);

  const columnDefs = useMemo(() => [
    { field: 'ticker', headerName: 'Ticker', pinned: 'left', width: 80 },
    { field: 'name', headerName: 'Company', pinned: 'left', width: 200 },
    { field: 'sector', headerName: 'Sector', width: 150 },
    { field: 'current_price', headerName: 'Price (€)', valueFormatter: priceFormatter },
    { field: 'market_cap', headerName: 'Market Cap', valueFormatter: largeNumberFormatter },
    { field: 'pe_ratio', headerName: 'P/E', valueFormatter: ratioFormatter },
    { field: 'dividend_yield', headerName: 'Div Yield', valueFormatter: percentFormatter },
    { field: 'roe', headerName: 'ROE', valueFormatter: percentFormatter },
    { field: 'revenue_growth', headerName: 'Rev Growth', valueFormatter: percentFormatter },
    { field: 'debt_to_equity', headerName: 'D/E Ratio', valueFormatter: ratioFormatter },
    { field: 'current_ratio', headerName: 'Current Ratio', valueFormatter: ratioFormatter },
    { field: 'beta', headerName: 'Beta', valueFormatter: ratioFormatter },
    { field: 'target_price', headerName: 'Target (€)', valueFormatter: priceFormatter },
    { field: 'recommendation', headerName: 'Rating', width: 100 },
  ], []);

  const defaultColDef = useMemo(() => ({
    sortable: true,
    filter: true,
    resizable: true,
    width: 120,
  }), []);

  // Formatters for European number display
  const priceFormatter = (params) => {
    if (params.value == null) return '';
    return params.value.toFixed(2).replace('.', ',') + ' €';
  };

  const percentFormatter = (params) => {
    if (params.value == null) return '';
    return (params.value * 100).toFixed(2).replace('.', ',') + '%';
  };

  const ratioFormatter = (params) => {
    if (params.value == null) return '';
    return params.value.toFixed(2).replace('.', ',');
  };

  const largeNumberFormatter = (params) => {
    if (params.value == null) return '';
    if (params.value >= 1e9) {
      return (params.value / 1e9).toFixed(2).replace('.', ',') + ' B€';
    }
    return (params.value / 1e6).toFixed(2).replace('.', ',') + ' M€';
  };

  return (
    <div className="ag-theme-alpine" style={{ height: '100%', width: '100%' }}>
      <AgGridReact
        rowData={stocks}
        columnDefs={columnDefs}
        defaultColDef={defaultColDef}
        onGridReady={(params) => setGridApi(params.api)}
        animateRows={true}
        rowSelection="multiple"
      />
    </div>
  );
};

export default StockGrid;
```

#### 3.3 Filter Panel Component
```javascript
// frontend/src/components/FilterPanel.js
import React, { useState } from 'react';

const FilterPanel = ({ metrics, onFilter, activeFilters }) => {
  const [filters, setFilters] = useState([]);
  const [logic, setLogic] = useState('AND');

  const operators = ['>', '<', '>=', '<=', '='];
  
  const presets = [
    { name: 'Value Stocks', id: 'value_stocks' },
    { name: 'Growth Stocks', id: 'growth_stocks' },
    { name: 'Dividend Champions', id: 'quality_dividend' },
    { name: 'Financial Health', id: 'financially_healthy' },
  ];

  const addFilter = () => {
    setFilters([...filters, { metric: '', operator: '>', value: '' }]);
  };

  const updateFilter = (index, field, value) => {
    const newFilters = [...filters];
    newFilters[index][field] = value;
    setFilters(newFilters);
  };

  const removeFilter = (index) => {
    setFilters(filters.filter((_, i) => i !== index));
  };

  const applyFilters = () => {
    const criteria = {};
    filters.forEach(filter => {
      if (filter.metric && filter.value) {
        criteria[filter.metric] = {
          operator: filter.operator,
          value: parseFloat(filter.value)
        };
      }
    });
    criteria.logic = logic;
    onFilter(criteria);
  };

  const clearFilters = () => {
    setFilters([]);
    onFilter({});
  };

  const loadPreset = async (presetId) => {
    // In a real app, fetch preset from backend
    // For now, using hardcoded presets
    const presetFilters = {
      value_stocks: [
        { metric: 'pe_ratio', operator: '<', value: '15' },
        { metric: 'dividend_yield', operator: '>', value: '0.03' }
      ],
      growth_stocks: [
        { metric: 'revenue_growth', operator: '>', value: '0.15' },
        { metric: 'earnings_growth', operator: '>', value: '0.15' }
      ],
      quality_dividend: [
        { metric: 'dividend_yield', operator: '>', value: '0.02' },
        { metric: 'payout_ratio', operator: '<', value: '0.6' },
        { metric: 'roe', operator: '>', value: '0.15' }
      ],
      financially_healthy: [
        { metric: 'current_ratio', operator: '>', value: '1.5' },
        { metric: 'debt_to_equity', operator: '<', value: '0.5' },
        { metric: 'roe', operator: '>', value: '0.1' }
      ]
    };
    
    setFilters(presetFilters[presetId] || []);
    setLogic('AND');
  };

  return (
    <div className="filter-panel">
      <h3>Stock Screening</h3>
      
      <div className="presets">
        <h4>Quick Filters</h4>
        {presets.map(preset => (
          <button 
            key={preset.id}
            onClick={() => loadPreset(preset.id)}
            className="preset-btn"
          >
            {preset.name}
          </button>
        ))}
      </div>

      <div className="custom-filters">
        <h4>Custom Filters</h4>
        
        <div className="logic-selector">
          <label>
            <input
              type="radio"
              value="AND"
              checked={logic === 'AND'}
              onChange={(e) => setLogic(e.target.value)}
            />
            Match ALL criteria (AND)
          </label>
          <label>
            <input
              type="radio"
              value="OR"
              checked={logic === 'OR'}
              onChange={(e) => setLogic(e.target.value)}
            />
            Match ANY criteria (OR)
          </label>
        </div>

        {filters.map((filter, index) => (
          <div key={index} className="filter-row">
            <select
              value={filter.metric}
              onChange={(e) => updateFilter(index, 'metric', e.target.value)}
            >
              <option value="">Select metric...</option>
              {metrics.map(metric => (
                <option key={metric} value={metric}>
                  {metric.replace(/_/g, ' ').toUpperCase()}
                </option>
              ))}
            </select>
            
            <select
              value={filter.operator}
              onChange={(e) => updateFilter(index, 'operator', e.target.value)}
            >
              {operators.map(op => (
                <option key={op} value={op}>{op}</option>
              ))}
            </select>
            
            <input
              type="number"
              step="0.01"
              value={filter.value}
              onChange={(e) => updateFilter(index, 'value', e.target.value)}
              placeholder="Value"
            />
            
            <button onClick={() => removeFilter(index)} className="remove-btn">
              ✕
            </button>
          </div>
        ))}
        
        <button onClick={addFilter} className="add-filter-btn">
          + Add Filter
        </button>
      </div>

      <div className="filter-actions">
        <button onClick={applyFilters} className="apply-btn">
          Apply Filters
        </button>
        <button onClick={clearFilters} className="clear-btn">
          Clear All
        </button>
      </div>
      
      {Object.keys(activeFilters).length > 0 && (
        <div className="active-filters">
          <h4>Active Filters</h4>
          <pre>{JSON.stringify(activeFilters, null, 2)}</pre>
        </div>
      )}
    </div>
  );
};

export default FilterPanel;
```

### Phase 4: Integration & Polish (4 hours)

#### 4.1 Update Panel Component
```javascript
// frontend/src/components/UpdatePanel.js
import React, { useState, useEffect } from 'react';

const UpdatePanel = ({ onUpdate }) => {
  const [updating, setUpdating] = useState(false);
  const [progress, setProgress] = useState({ current: 0, total: 0, ticker: '' });

  useEffect(() => {
    if (updating) {
      const interval = setInterval(checkProgress, 1000);
      return () => clearInterval(interval);
    }
  }, [updating]);

  const checkProgress = async () => {
    try {
      const response = await fetch('http://localhost:8000/api/stocks/update/progress');
      const data = await response.json();
      setProgress({
        current: data.current,
        total: data.total,
        ticker: data.current_ticker
      });
      
      if (data.status === 'completed') {
        setUpdating(false);
        onUpdate(); // Refresh stock list
      }
    } catch (error) {
      console.error('Error checking progress:', error);
    }
  };

  const startUpdate = async () => {
    setUpdating(true);
    try {
      await fetch('http://localhost:8000/api/stocks/update', {
        method: 'POST'
      });
    } catch (error) {
      console.error('Error starting update:', error);
      setUpdating(false);
    }
  };

  const progressPercent = progress.total > 0 
    ? Math.round((progress.current / progress.total) * 100) 
    : 0;

  return (
    <div className="update-panel">
      <h3>Data Updates</h3>
      
      <button 
        onClick={startUpdate} 
        disabled={updating}
        className="update-btn"
      >
        {updating ? 'Updating...' : 'Update All Data'}
      </button>
      
      {updating && (
        <div className="progress-info">
          <div className="progress-bar">
            <div 
              className="progress-fill" 
              style={{ width: `${progressPercent}%` }}
            />
          </div>
          <div className="progress-text">
            {progress.current} / {progress.total} stocks
            {progress.ticker && ` (${progress.ticker})`}
          </div>
          <div className="progress-percent">{progressPercent}%</div>
        </div>
      )}
    </div>
  );
};

export default UpdatePanel;
```

#### 4.2 Export Panel Component
```javascript
// frontend/src/components/ExportPanel.js
import React, { useState } from 'react';

const ExportPanel = ({ activeFilters, metrics }) => {
  const [selectedColumns, setSelectedColumns] = useState([]);
  const [selectAll, setSelectAll] = useState(true);

  const handleExport = async () => {
    const params = new URLSearchParams();
    
    if (!selectAll && selectedColumns.length > 0) {
      params.append('columns', selectedColumns.join(','));
    }
    
    const url = 'http://localhost:8000/api/export/csv?' + params.toString();
    
    try {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ filters: activeFilters })
      });
      
      const blob = await response.blob();
      const downloadUrl = window.URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = downloadUrl;
      link.download = `aurus_sbf250_export_${new Date().toISOString().slice(0, 10)}.csv`;
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (error) {
      console.error('Error exporting:', error);
    }
  };

  const toggleColumn = (metric) => {
    if (selectedColumns.includes(metric)) {
      setSelectedColumns(selectedColumns.filter(m => m !== metric));
    } else {
      setSelectedColumns([...selectedColumns, metric]);
    }
  };

  return (
    <div className="export-panel">
      <h3>Export Data</h3>
      
      <div className="export-options">
        <label>
          <input
            type="radio"
            checked={selectAll}
            onChange={() => setSelectAll(true)}
          />
          Export all columns
        </label>
        
        <label>
          <input
            type="radio"
            checked={!selectAll}
            onChange={() => setSelectAll(false)}
          />
          Select columns
        </label>
      </div>
      
      {!selectAll && (
        <div className="column-selector">
          {metrics.map(metric => (
            <label key={metric}>
              <input
                type="checkbox"
                checked={selectedColumns.includes(metric)}
                onChange={() => toggleColumn(metric)}
              />
              {metric.replace(/_/g, ' ')}
            </label>
          ))}
        </div>
      )}
      
      <button onClick={handleExport} className="export-btn">
        Export to CSV
      </button>
      
      {Object.keys(activeFilters).length > 0 && (
        <p className="export-note">
          Export will include only filtered results
        </p>
      )}
    </div>
  );
};

export default ExportPanel;
```

## Requirements

### Backend Requirements (requirements.txt)
```
fastapi==0.104.1
uvicorn==0.24.0
yfinance==0.2.33
pandas==2.1.3
sqlalchemy==2.0.23
pydantic==2.5.0
python-multipart==0.0.6
```

### Frontend Requirements (package.json)
```json
{
  "name": "aurus-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "ag-grid-community": "^31.0.0",
    "ag-grid-react": "^31.0.0",
    "axios": "^1.6.0"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "proxy": "http://localhost:8000"
}
```

### Running the Application

1. **Start Backend**:
```bash
cd backend
pip install -r requirements.txt
uvicorn app.main:app --reload
```

2. **Start Frontend**:
```bash
cd frontend
npm install
npm start
```

3. **First Run**:
- Click "Update All Data" to fetch SBF 250 stocks
- Wait for progress to complete (will take ~2-3 minutes)
- Start screening and analyzing!

## Validation Strategy

### Testing Checklist:
1. ✓ All 250 stocks load with data
2. ✓ Filters work correctly (AND/OR logic)
3. ✓ CSV export includes proper formatting
4. ✓ Update progress shows real-time status
5. ✓ Error handling for missing data
6. ✓ Rate limiting prevents API blocks

### Performance Targets:
- Initial data load: < 3 minutes for all 250 stocks
- Filter application: < 1 second
- CSV export: < 2 seconds
- UI responsiveness: 60 FPS scrolling in grid

## Next Steps & Enhancements

After the MVP is working:
1. Add portfolio optimization algorithms
2. Historical price charts
3. Comparison tools
4. Save/load filter sets
5. Automated daily updates
6. More sophisticated screening logic